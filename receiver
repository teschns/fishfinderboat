# Receiver (CircuitPython)

import time, board, busio, digitalio, pwmio
import adafruit_rfm69, adafruit_bno055

# === Radio Setup ===
cs = digitalio.DigitalInOut(board.RFM_CS)
rst = digitalio.DigitalInOut(board.RFM_RST)
cs.switch_to_output(); rst.switch_to_output()

spi = busio.SPI(board.SCK, board.MOSI, board.MISO)
rfm = adafruit_rfm69.RFM69(spi, cs, rst, 915.0)
rfm.tx_power = 13
print("RFM69 receiver ready")

# === Motor Driver Setup ===
AIN1 = pwmio.PWMOut(board.D13, frequency=1000)
AIN2 = digitalio.DigitalInOut(board.D12); AIN2.switch_to_output()

BIN1 = pwmio.PWMOut(board.D10, frequency=1000)
BIN2 = digitalio.DigitalInOut(board.D9); BIN2.switch_to_output()

SLP = digitalio.DigitalInOut(board.D5); SLP.switch_to_output(); SLP.value = True

# === IMU Setup ===
i2c = busio.I2C(board.SCL, board.SDA)
imu = adafruit_bno055.BNO055_I2C(i2c)

# === Control Logic ===
NEUTRAL = 128
MAX = 65535
TIMEOUT = 0.5
kp = 0.005

last_time = time.monotonic()
target_heading = None
heading_hold = False

def set_motor(pwm, dirpin, speed, forward=True):
    pwm.duty_cycle = abs(speed)
    dirpin.value = not forward

while True:
    pkt = rfm.receive(timeout=0.1)
    current = time.monotonic()

    if pkt:
        last_time = current
        try:
            y, x, mode = map(int, pkt.decode().split(","))
        except:
            continue

        # Throttle: -127..127
        norm = (y - NEUTRAL) / (255 - NEUTRAL)
        base = int(abs(norm) * MAX)
        forward = (norm >= 0)

        # Steering diff: -base..base
        diff = int(((x - NEUTRAL) / (255 - NEUTRAL)) * base)

        # Mode toggle (on transmitter), capture heading
        if mode and not heading_hold:
            heading_hold = True
            target_heading = imu.euler[0] if imu.euler else 0
        elif mode == 0:
            heading_hold = False

        # Heading hold adjustment
        if heading_hold and imu.euler:
            h = imu.euler[0]
            err = ((h - target_heading + 540) % 360) - 180
            adjust = kp * err
            left = base - int(adjust * base)
            right = base + int(adjust * base)
        else:
            left = base - diff
            right = base + diff

        set_motor(AIN1, AIN2, left, forward)
        set_motor(BIN1, BIN2, right, forward)

        print(f"Y:{y} X:{x} Mode:{mode} LH:{left} RH:{right}")

    # Timeout â€” stop motors if no packet for TIMEOUT
    if current - last_time > TIMEOUT:
        set_motor(AIN1, AIN2, 0, True)
        set_motor(BIN1, BIN2, 0, True)

    time.sleep(0.02)
