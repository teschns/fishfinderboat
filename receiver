import time
import board
import busio
import digitalio
import pwmio
import adafruit_rfm69
import adafruit_bno055

# --- Radio Setup ---
RADIO_FREQ_MHZ = 915.0
CS = digitalio.DigitalInOut(board.RFM_CS)
RESET = digitalio.DigitalInOut(board.RFM_RST)
CS.switch_to_output()
RESET.switch_to_output()
spi = busio.SPI(board.SCK, board.MOSI, board.MISO)
rfm69 = adafruit_rfm69.RFM69(spi, CS, RESET, RADIO_FREQ_MHZ)
rfm69.tx_power = 13
print("RFM69 receiver ready")

# --- IMU Setup ---
i2c = busio.I2C(board.SCL, board.SDA)
bno = adafruit_bno055.BNO055_I2C(i2c)

# --- Motor Setup ---
AIN1 = pwmio.PWMOut(board.D13, frequency=1000)
AIN2 = digitalio.DigitalInOut(board.D12)
AIN2.switch_to_output()

BIN1 = pwmio.PWMOut(board.D10, frequency=1000)
BIN2 = digitalio.DigitalInOut(board.D11)
BIN2.switch_to_output()

SLP = digitalio.DigitalInOut(board.D5)
SLP.switch_to_output()
SLP.value = True

# --- Constants ---
MAX_SPEED = 65535
NEUTRAL = 128
STEER_GAIN = 5  # proportional gain for heading hold

# --- Utility ---
def set_motor(pwm, dir_pin, speed):
    if speed >= 0:
        dir_pin.value = False  # forward
        pwm.duty_cycle = min(int(speed), MAX_SPEED)
    else:
        dir_pin.value = True  # reverse
        pwm.duty_cycle = min(int(-speed), MAX_SPEED)


# --- Main Loop ---
while True:
    packet = rfm69.receive()
    if packet is not None:
        try:
            data = packet.decode().split(",")
            mode = int(data[0])
            throttle_val = int(data[1])
            x_val = int(data[2])
            heading_cmd = int(data[3])

            if mode == 0:  # Manual Mode
                JOYSTICK_CENTER = 120
                JOYSTICK_RANGE = 127  # scale from -1 to 1

                # Normalize
                throttle = (throttle_val - JOYSTICK_CENTER) / JOYSTICK_RANGE
                steer = (x_val - JOYSTICK_CENTER) / JOYSTICK_RANGE

                # Apply deadzone
                if abs(throttle) < 0.05:
                    throttle = 0
                if abs(steer) < 0.05:
                    steer = 0
                # Mixing for differential drive
                left_speed = throttle - steer
                right_speed = throttle + steer

                # Clamp outputs to [-1, 1] to avoid exceeding PWM limits
                left_speed = max(-1, min(1, left_speed))
                right_speed = max(-1, min(1, right_speed))

                # Scale to PWM range
                set_motor(AIN1, AIN2, left_speed * MAX_SPEED)
                set_motor(BIN1, BIN2, right_speed * MAX_SPEED)

                print(
                    f"Manual: Throttle={throttle:.2f} Steer={steer:.2f} Right={right_speed:.2f} Left={left_speed:.2f} Rx={throttle_val} {x_val}"
                )
            
            
            elif mode == 1:  # Heading Hold Mode
                current_heading = bno.euler[0] or 0  # handle None

                # Wrap-around safe heading error
                heading_error = (heading_cmd - current_heading + 540) % 360 - 180

                # Apply simple proportional gain (reduce gain for stability)
                correction = heading_error * 0.02  # much lower gain

                # Clamp correction to avoid wild steering
                correction = max(-1, min(1, correction))

                JOYSTICK_CENTER = 120
                FORWARD_RANGE = 127
                REVERSE_RANGE = 120

                raw_throttle = throttle_val - JOYSTICK_CENTER

                if raw_throttle >= 0:
                    throttle = raw_throttle / FORWARD_RANGE
                else:
                    throttle = raw_throttle / -REVERSE_RANGE


                # Deadzone
                if abs(throttle) < 0.05:
                    throttle = 0

                # Clamp
                throttle = max(-1, min(1, throttle))

                # Apply mixing
                left_speed = throttle - correction
                right_speed = throttle + correction

                # Clamp final motor speeds
                left_speed = max(-1, min(1, left_speed))
                right_speed = max(-1, min(1, right_speed))

                # Output to motors
                set_motor(AIN1, AIN2, left_speed * MAX_SPEED)
                set_motor(BIN1, BIN2, right_speed * MAX_SPEED)

                print(
                    f"Heading Hold: T={throttle:.2f} Hcmd={heading_cmd} Hcur={current_heading:.1f} Err={heading_error:.1f} Corr={correction:.2f}"
                )
            
            elif mode == 2:
                # GPS mode placeholder
                set_motor(AIN1, AIN2, 0)
                set_motor(BIN1, BIN2, 0)
                print("GPS Mode (inactive)")
        except Exception as e:
            print("Error:", e)
    time.sleep(0.05)
